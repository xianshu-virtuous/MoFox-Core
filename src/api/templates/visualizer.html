<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoFox Bot - è®°å¿†å›¾å¯è§†åŒ–</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }

        .sidebar {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .graph-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
            position: relative;
        }

        #memory-graph {
            width: 100%;
            height: 100%;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h2 {
            color: #555;
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .search-box input {
            flex: 1;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .search-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 13px;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .filter-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .filter-item label {
            flex: 1;
            font-size: 13px;
            cursor: pointer;
        }

        .performance-mode {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background: #fff3cd;
            border-radius: 6px;
            border: 1px solid #ffc107;
        }

        .performance-mode h3 {
            font-size: 13px;
            color: #856404;
            margin: 0;
        }

        .performance-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .performance-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .performance-item input[type="radio"] {
            cursor: pointer;
        }

        .performance-item label {
            cursor: pointer;
            flex: 1;
        }

        .performance-tips {
            margin-top: 8px;
            padding: 8px;
            background: #e8f5e9;
            border-radius: 4px;
            font-size: 11px;
            color: #2e7d32;
            line-height: 1.4;
        }

        .performance-tips strong {
            display: block;
            margin-bottom: 4px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #667eea;
            font-size: 18px;
            font-weight: 500;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .loading-progress {
            margin-top: 10px;
            font-size: 14px;
            color: #764ba2;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }

        .info-panel h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 8px;
        }

        .info-panel p {
            margin: 4px 0;
            color: #555;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        /* æ–‡ä»¶é€‰æ‹©å™¨æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: relative;
            background: white;
            margin: 5% auto;
            padding: 30px;
            width: 80%;
            max-width: 700px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
        }

        .close-btn {
            font-size: 28px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: #333;
        }

        .file-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .file-item:hover {
            background: #e9ecef;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .file-item.current {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        }

        .file-item-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .file-item-info {
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }

        .file-item-current {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                max-height: 300px;
            }
            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¾§è¾¹æ  -->
        <div class="sidebar">
            <h1>ğŸ¦Š è®°å¿†å›¾å¯è§†åŒ–</h1>
            
            <!-- æ–‡ä»¶é€‰æ‹© -->
            <div>
                <h2>ğŸ“‚ æ•°æ®æ–‡ä»¶</h2>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="btn" style="flex: 1;" onclick="showFileSelector()">é€‰æ‹©æ–‡ä»¶</button>
                    <button class="btn btn-secondary" style="flex: 1;" onclick="loadFileList()">åˆ·æ–°åˆ—è¡¨</button>
                </div>
                <div id="currentFileInfo" style="font-size: 12px; color: #666; padding: 8px; background: #f8f9fa; border-radius: 6px;">
                    <p>åŠ è½½ä¸­...</p>
                </div>
            </div>

            <!-- æœç´¢ -->
            <div>
                <h2>ğŸ” æœç´¢è®°å¿†</h2>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="è¾“å…¥å…³é”®è¯æœç´¢...">
                    <button class="btn" onclick="searchMemories()">æœç´¢</button>
                </div>
            </div>

            <!-- ç»Ÿè®¡ä¿¡æ¯ -->
            <div>
                <h2>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h2>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="statNodes">0</div>
                        <div class="stat-label">èŠ‚ç‚¹æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statEdges">0</div>
                        <div class="stat-label">è¾¹æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statMemories">0</div>
                        <div class="stat-label">è®°å¿†æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statDensity">0%</div>
                        <div class="stat-label">å›¾å¯†åº¦</div>
                    </div>
                </div>
            </div>

            <!-- èŠ‚ç‚¹ç±»å‹å›¾ä¾‹ -->
            <div>
                <h2>ğŸ¨ èŠ‚ç‚¹ç±»å‹</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF6B6B;"></div>
                        <span>ä¸»ä½“ (SUBJECT)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ECDC4;"></div>
                        <span>ä¸»é¢˜ (TOPIC)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #45B7D1;"></div>
                        <span>å®¢ä½“ (OBJECT)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFA07A;"></div>
                        <span>å±æ€§ (ATTRIBUTE)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #98D8C8;"></div>
                        <span>å€¼ (VALUE)</span>
                    </div>
                </div>
            </div>

            <!-- è¿‡æ»¤å™¨ -->
            <div>
                <h2>ğŸ”§ è¿‡æ»¤å™¨</h2>
                <div class="filter-group">
                    <div class="filter-item">
                        <input type="checkbox" id="filterSubject" checked onchange="applyFilters()">
                        <label for="filterSubject">æ˜¾ç¤ºä¸»ä½“èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterTopic" checked onchange="applyFilters()">
                        <label for="filterTopic">æ˜¾ç¤ºä¸»é¢˜èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterObject" checked onchange="applyFilters()">
                        <label for="filterObject">æ˜¾ç¤ºå®¢ä½“èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterAttribute" checked onchange="applyFilters()">
                        <label for="filterAttribute">æ˜¾ç¤ºå±æ€§èŠ‚ç‚¹</label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filterValue" checked onchange="applyFilters()">
                        <label for="filterValue">æ˜¾ç¤ºå€¼èŠ‚ç‚¹</label>
                    </div>
                </div>
            </div>

            <!-- æ€§èƒ½æ¨¡å¼ -->
            <div>
                <h2>âš¡ æ€§èƒ½æ¨¡å¼</h2>
                <div class="performance-mode">
                    <h3>æ•°æ®åŠ è½½æ¨¡å¼</h3>
                    <div class="performance-options">
                        <div class="performance-item">
                            <input type="radio" id="modeAuto" name="loadMode" value="auto" checked onchange="changeLoadMode()">
                            <label for="modeAuto">è‡ªåŠ¨é€‰æ‹©ï¼ˆæ¨èï¼‰</label>
                        </div>
                        <div class="performance-item">
                            <input type="radio" id="modeFull" name="loadMode" value="full" onchange="changeLoadMode()">
                            <label for="modeFull">å®Œæ•´åŠ è½½ï¼ˆ&lt;500èŠ‚ç‚¹ï¼‰</label>
                        </div>
                        <div class="performance-item">
                            <input type="radio" id="modeCluster" name="loadMode" value="cluster" onchange="changeLoadMode()">
                            <label for="modeCluster">èšç±»ç®€åŒ–ï¼ˆ300èŠ‚ç‚¹ï¼‰</label>
                        </div>
                        <div class="performance-item">
                            <input type="radio" id="modePaginated" name="loadMode" value="paginated" onchange="changeLoadMode()">
                            <label for="modePaginated">åˆ†é¡µåŠ è½½ï¼ˆ500/é¡µï¼‰</label>
                        </div>
                    </div>
                    <div class="performance-tips">
                        <strong>ğŸ’¡ æ€§èƒ½æç¤ºï¼š</strong>
                        â€¢ èŠ‚ç‚¹ &gt;500: ä¼˜å…ˆä½¿ç”¨èšç±»æˆ–åˆ†é¡µæ¨¡å¼<br>
                        â€¢ åŠ è½½å®Œæˆåç‚¹å‡»"ç¦ç”¨ç‰©ç†"æŒ‰é’®<br>
                        â€¢ é¼ æ ‡æ‚¬åœå¯æŸ¥çœ‹èŠ‚ç‚¹æ ‡ç­¾<br>
                        â€¢ ç‚¹å‡»èŠ‚ç‚¹é«˜äº®å…³è”è·¯å¾„ï¼ˆå®Œæ•´æ¨¡å¼1è·³ï¼‰
                    </div>
                </div>
            </div>

            <!-- é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯ -->
            <div>
                <h2>â„¹ï¸ èŠ‚ç‚¹ä¿¡æ¯</h2>
                <div class="info-panel" id="nodeInfo">
                    <p style="color: #999;">ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</p>
                </div>
            </div>
        </div>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="controls">
                <div class="control-buttons">
                    <button class="btn" onclick="loadGraph()">ğŸ”„ åˆ·æ–°å›¾å½¢</button>
                    <button class="btn btn-secondary" onclick="fitNetwork()">ğŸ“ é€‚åº”çª—å£</button>
                    <button class="btn" onclick="exportGraph()">ğŸ’¾ å¯¼å‡ºæ•°æ®</button>
                    <button class="btn" onclick="togglePhysics()" id="physicsToggle">âš™ï¸ å¯ç”¨ç‰©ç†</button>
                </div>
                <div id="paginationControls" class="control-buttons" style="margin-top: 10px; display: none;">
                    <button class="btn" onclick="loadPreviousPage()" id="prevPageBtn">â¬…ï¸ ä¸Šä¸€é¡µ</button>
                    <span style="padding: 10px; font-size: 14px; font-weight: bold;" id="pageInfo">ç¬¬ 1 é¡µ</span>
                    <button class="btn" onclick="loadNextPage()" id="nextPageBtn">ä¸‹ä¸€é¡µ â¡ï¸</button>
                </div>
            </div>

            <!-- å›¾å½¢æ˜¾ç¤ºåŒº -->
            <div class="graph-container">
                <div id="memory-graph"></div>
                <div class="loading" id="loading">
                    <div class="loading-spinner"></div>
                    <div>æ­£åœ¨åŠ è½½è®°å¿†å›¾...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ–‡ä»¶é€‰æ‹©æ¨¡æ€æ¡† -->
    <div id="fileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ“‚ é€‰æ‹©æ•°æ®æ–‡ä»¶</h2>
                <span class="close-btn" onclick="closeFileSelector()">&times;</span>
            </div>
            <div id="fileListContainer">
                <div style="text-align: center; padding: 20px;">
                    <div class="loading-spinner"></div>
                    <p>åŠ è½½æ–‡ä»¶åˆ—è¡¨...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let network = null;
        let availableFiles = [];
        let graphData = {
            nodes: [],
            edges: [],
            memories: []
        };
        let originalData = null;
        let currentLoadMode = 'auto';
        let currentPage = 1;
        let totalPages = 1;
        let isLoading = false;
        let hoveredNodeId = null;  // å½“å‰é¼ æ ‡æ‚¬åœçš„èŠ‚ç‚¹ID
        let highlightedNodeIds = new Set();  // å½“å‰é«˜äº®çš„èŠ‚ç‚¹IDé›†åˆ
        
        // é‚»æ¥è¡¨ç¼“å­˜ï¼Œç”¨äºé«˜äº®ä¼˜åŒ–
        let adjacencyCache = null;
        let nodeDegreeCache = null;

        // èŠ‚ç‚¹é¢œè‰²é…ç½®
        const nodeColors = {
            'SUBJECT': '#FF6B6B',
            'TOPIC': '#4ECDC4',
            'OBJECT': '#45B7D1',
            'ATTRIBUTE': '#FFA07A',
            'VALUE': '#98D8C8'
        };

        // åˆ‡æ¢åŠ è½½æ¨¡å¼
        function changeLoadMode() {
            const selected = document.querySelector('input[name="loadMode"]:checked');
            if (selected) {
                currentLoadMode = selected.value;
                console.log('åˆ‡æ¢åŠ è½½æ¨¡å¼:', currentLoadMode);
                loadGraph();
            }
        }

        // æ„å»ºé‚»æ¥è¡¨ç¼“å­˜
        function buildAdjacencyCache(edges) {
            adjacencyCache = new Map();
            nodeDegreeCache = new Map();
            
            edges.forEach(edge => {
                const from = edge.from;
                const to = edge.to;
                
                if (!adjacencyCache.has(from)) {
                    adjacencyCache.set(from, []);
                    nodeDegreeCache.set(from, 0);
                }
                if (!adjacencyCache.has(to)) {
                    adjacencyCache.set(to, []);
                    nodeDegreeCache.set(to, 0);
                }
                
                adjacencyCache.get(from).push({ nodeId: to, edgeId: edge.id });
                adjacencyCache.get(to).push({ nodeId: from, edgeId: edge.id });
                nodeDegreeCache.set(from, nodeDegreeCache.get(from) + 1);
                nodeDegreeCache.set(to, nodeDegreeCache.get(to) + 1);
            });
            
            console.log(`é‚»æ¥è¡¨ç¼“å­˜æ„å»ºå®Œæˆ: ${adjacencyCache.size} ä¸ªèŠ‚ç‚¹`);
        }

        // åˆå§‹åŒ–å›¾å½¢
        function initNetwork() {
            const container = document.getElementById('memory-graph');
            
            // åŠ¨æ€é…ç½®ï¼šå¤§æ•°æ®é›†ä½¿ç”¨æç®€é…ç½®
            const getNetworkOptions = (nodeCount) => {
                const isLargeDataset = nodeCount > 500;
                const isVeryLargeDataset = nodeCount > 2000;
                
                return {
                    nodes: {
                        shape: 'dot',
                        size: isVeryLargeDataset ? 10 : (isLargeDataset ? 15 : 20),
                        font: {
                            size: isVeryLargeDataset ? 0 : (isLargeDataset ? 10 : 14),  // è¶…å¤§æ•°æ®é›†éšè—æ–‡å­—
                            color: '#333',
                            face: 'Microsoft YaHei'
                        },
                        borderWidth: isVeryLargeDataset ? 0 : 2,
                        borderWidthSelected: 3,
                        shadow: false,  // å§‹ç»ˆç¦ç”¨é˜´å½±
                        scaling: {
                            min: isVeryLargeDataset ? 5 : 10,
                            max: isVeryLargeDataset ? 15 : 30
                        }
                    },
                    edges: {
                        width: isVeryLargeDataset ? 0.5 : (isLargeDataset ? 1 : 2),
                        color: {
                            color: '#848484',
                            highlight: '#667eea',
                            hover: '#764ba2',
                            opacity: isVeryLargeDataset ? 0.3 : 0.7  // è¶…å¤§æ•°æ®é›†è¾¹åŠé€æ˜
                        },
                        arrows: {
                            to: {
                                enabled: !isVeryLargeDataset,  // è¶…å¤§æ•°æ®é›†ç¦ç”¨ç®­å¤´
                                scaleFactor: 0.3
                            }
                        },
                        smooth: false,  // å§‹ç»ˆç¦ç”¨å¹³æ»‘ä»¥æå‡æ€§èƒ½
                        font: {
                            size: 0,  // å§‹ç»ˆéšè—è¾¹æ ‡ç­¾
                            strokeWidth: 0
                        },
                        shadow: false,
                        selectionWidth: 2
                    },
                    physics: {
                        enabled: true,
                        barnesHut: {
                            gravitationalConstant: isVeryLargeDataset ? -800 : (isLargeDataset ? -2000 : -8000),
                            centralGravity: isVeryLargeDataset ? 0.1 : 0.3,
                            springLength: isVeryLargeDataset ? 50 : (isLargeDataset ? 95 : 150),
                            springConstant: isVeryLargeDataset ? 0.001 : (isLargeDataset ? 0.02 : 0.04),
                            damping: isVeryLargeDataset ? 0.3 : 0.09,
                            avoidOverlap: 0
                        },
                        stabilization: {
                            enabled: true,
                            iterations: isVeryLargeDataset ? 50 : (isLargeDataset ? 100 : 300),
                            updateInterval: isVeryLargeDataset ? 100 : (isLargeDataset ? 50 : 25),
                            onlyDynamicEdges: false,
                            fit: true
                        },
                        solver: 'barnesHut',
                        timestep: isVeryLargeDataset ? 1.0 : 0.5,
                        adaptiveTimestep: true,
                        maxVelocity: isVeryLargeDataset ? 100 : 50,
                        minVelocity: isVeryLargeDataset ? 5 : 0.75
                    },
                    interaction: {
                        hover: true,  // å§‹ç»ˆå¯ç”¨hover - æˆ‘ä»¬ç”¨è‡ªå®šä¹‰äº‹ä»¶å¤„ç†æ ‡ç­¾æ˜¾ç¤º
                        tooltipDelay: 300,
                        zoomView: true,
                        dragView: true,
                        hideEdgesOnDrag: true,  // å§‹ç»ˆåœ¨æ‹–æ‹½æ—¶éšè—è¾¹
                        hideEdgesOnZoom: true,  // å§‹ç»ˆåœ¨ç¼©æ”¾æ—¶éšè—è¾¹
                        hideNodesOnDrag: isVeryLargeDataset,  // è¶…å¤§æ•°æ®é›†æ‹–æ‹½æ—¶ä¹Ÿéšè—èŠ‚ç‚¹
                        navigationButtons: false,
                        keyboard: false
                    },
                    layout: {
                        improvedLayout: !isVeryLargeDataset,  // è¶…å¤§æ•°æ®é›†ç¦ç”¨æ”¹è¿›å¸ƒå±€
                        randomSeed: 2  // å›ºå®šéšæœºç§å­ä»¥è·å¾—ä¸€è‡´çš„å¸ƒå±€
                    }
                };
            };

            const data = {
                nodes: new vis.DataSet([]),
                edges: new vis.DataSet([])
            };

            // åˆå§‹ä½¿ç”¨ä¸­ç­‰é…ç½®
            network = new vis.Network(container, data, getNetworkOptions(500));
            
            // ä¿å­˜é…ç½®å‡½æ•°ä¾›åç»­ä½¿ç”¨
            network.updateOptions = (nodeCount) => {
                network.setOptions(getNetworkOptions(nodeCount));
            };

            // æ·»åŠ äº‹ä»¶ç›‘å¬
            network.on('click', function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    showNodeInfo(nodeId);
                    highlightConnectedNodes(nodeId);
                } else {
                    // ç‚¹å‡»ç©ºç™½å¤„ï¼Œæ¢å¤æ‰€æœ‰èŠ‚ç‚¹
                    resetNodeHighlight();
                }
            });

            // æ·»åŠ é¼ æ ‡æ‚¬åœäº‹ä»¶ï¼ˆä»…åœ¨å°æ•°æ®é›†å¯ç”¨ï¼‰
            network.on('hoverNode', function(params) {
                hoveredNodeId = params.node;
                updateNodeLabel(params.node, true);  // æ˜¾ç¤ºæ‚¬åœèŠ‚ç‚¹çš„æ ‡ç­¾
            });

            network.on('blurNode', function(params) {
                // å¦‚æœèŠ‚ç‚¹ä¸åœ¨é«˜äº®é›†åˆä¸­ï¼Œéšè—æ ‡ç­¾
                if (!highlightedNodeIds.has(params.node)) {
                    updateNodeLabel(params.node, false);
                }
                hoveredNodeId = null;
            });

            // ç¨³å®šåŒ–å®Œæˆååœæ­¢ç‰©ç†å¼•æ“
            network.on('stabilizationIterationsDone', function() {
                console.log('ç¨³å®šåŒ–å®Œæˆï¼Œåœæ­¢ç‰©ç†å¼•æ“');
                network.setOptions({ physics: { enabled: false } });
                updateLoadingProgress('å¸ƒå±€å®Œæˆ');
            });

            // æ·»åŠ ç¨³å®šåŒ–è¿›åº¦ç›‘å¬
            network.on('stabilizationProgress', function(params) {
                const progress = Math.round((params.iterations / params.total) * 100);
                updateLoadingProgress(`å¸ƒå±€ä¸­: ${progress}%`);
            });
        }

        // æ›´æ–°åŠ è½½è¿›åº¦æç¤º
        function updateLoadingProgress(message) {
            const progressDiv = document.querySelector('.loading-progress');
            if (progressDiv) {
                progressDiv.textContent = message;
            } else {
                const loadingDiv = document.getElementById('loading');
                if (loadingDiv) {
                    const existing = loadingDiv.querySelector('.loading-progress');
                    if (!existing) {
                        const newDiv = document.createElement('div');
                        newDiv.className = 'loading-progress';
                        newDiv.textContent = message;
                        loadingDiv.appendChild(newDiv);
                    } else {
                        existing.textContent = message;
                    }
                }
            }
        }

        // åŠ¨æ€æ›´æ–°èŠ‚ç‚¹æ ‡ç­¾æ˜¾ç¤º
        function updateNodeLabel(nodeId, show) {
            if (!network || !graphData) return;
            
            const nodes = network.body.data.nodes;
            const node = nodes.get(nodeId);
            if (!node) return;
            
            // è·å–åŸå§‹èŠ‚ç‚¹æ•°æ®
            const originalNode = graphData.nodes.find(n => n.id === nodeId);
            if (!originalNode) return;
            
            // æ›´æ–°èŠ‚ç‚¹æ ‡ç­¾
            nodes.update({
                id: nodeId,
                label: show ? originalNode.label : '',
                font: show ? { size: 14, color: '#333' } : { size: 0 }
            });
        }

        // æ‰¹é‡æ›´æ–°è¾¹æ ‡ç­¾æ˜¾ç¤º
        function updateEdgeLabels(edgeIds, show) {
            if (!network || !graphData || edgeIds.size === 0) return;
            
            const edges = network.body.data.edges;
            const edgeUpdates = [];
            
            edgeIds.forEach(edgeId => {
                const edge = edges.get(edgeId);
                if (!edge) return;
                
                // è·å–åŸå§‹è¾¹æ•°æ®
                const originalEdge = graphData.edges.find(e => e.id === edgeId);
                if (!originalEdge) return;
                
                edgeUpdates.push({
                    id: edgeId,
                    label: show ? (originalEdge.label || '') : '',
                    font: show ? { size: 11, color: '#666' } : { size: 0 }
                });
            });
            
            if (edgeUpdates.length > 0) {
                edges.update(edgeUpdates);
            }
        }

        // åŠ è½½å›¾å½¢æ•°æ®ï¼ˆæ™ºèƒ½é€‰æ‹©æ¨¡å¼ï¼‰
        async function loadGraph() {
            if (isLoading) {
                console.log('å·²æœ‰åŠ è½½ä»»åŠ¡åœ¨è¿›è¡Œä¸­');
                return;
            }

            try {
                isLoading = true;
                document.getElementById('loading').style.display = 'block';
                updateLoadingProgress('è·å–æ•°æ®æ‘˜è¦...');
                
                // é¦–å…ˆè·å–æ‘˜è¦ä¿¡æ¯ä»¥å†³å®šåŠ è½½ç­–ç•¥
                const summaryResponse = await fetch('/visualizer/api/graph/summary');
                const summaryResult = await summaryResponse.json();
                
                if (!summaryResult.success) {
                    throw new Error(summaryResult.error);
                }
                
                const totalNodes = summaryResult.data.stats.total_nodes;
                console.log(`å›¾æ•°æ®èŠ‚ç‚¹æ€»æ•°: ${totalNodes}`);
                
                // æ ¹æ®æ¨¡å¼å’Œæ•°æ®é‡é€‰æ‹©åŠ è½½ç­–ç•¥ï¼ˆæ›´ä¿å®ˆçš„é˜ˆå€¼ï¼‰
                let loadMode = currentLoadMode;
                if (loadMode === 'auto') {
                    if (totalNodes <= 500) {
                        loadMode = 'full';
                    } else if (totalNodes <= 2000) {
                        loadMode = 'cluster';
                    } else {
                        loadMode = 'paginated';
                    }
                    console.log(`è‡ªåŠ¨é€‰æ‹©åŠ è½½æ¨¡å¼: ${loadMode} (èŠ‚ç‚¹æ•°: ${totalNodes})`);
                }
                
                // æ ¹æ®é€‰æ‹©çš„æ¨¡å¼åŠ è½½æ•°æ®
                let result;
                if (loadMode === 'full') {
                    updateLoadingProgress('åŠ è½½å®Œæ•´æ•°æ®...');
                    result = await loadFullGraph();
                } else if (loadMode === 'cluster') {
                    updateLoadingProgress('åŠ è½½èšç±»æ•°æ®...');
                    result = await loadClusteredGraph();
                } else if (loadMode === 'paginated') {
                    updateLoadingProgress('åŠ è½½åˆ†é¡µæ•°æ® (ç¬¬1é¡µ)...');
                    result = await loadPaginatedGraph(1);
                }
                
                if (result && result.success) {
                    updateLoadingProgress('æ¸²æŸ“å›¾å½¢...');
                    originalData = result.data;
                    updateGraph(result.data);
                    updateStats(result.data.stats);
                    
                    // æ„å»ºç¼“å­˜ä»¥ä¼˜åŒ–åç»­æ“ä½œ
                    buildAdjacencyCache(result.data.edges || []);
                    
                    // æ˜¾ç¤º/éšè—åˆ†é¡µæ§åˆ¶
                    const paginationControls = document.getElementById('paginationControls');
                    if (result.data.pagination) {
                        const p = result.data.pagination;
                        totalPages = p.total_pages;
                        currentPage = p.page;
                        paginationControls.style.display = 'flex';
                        document.getElementById('pageInfo').textContent = `ç¬¬ ${p.page}/${p.total_pages} é¡µ`;
                        document.getElementById('prevPageBtn').disabled = !p.has_prev;
                        document.getElementById('nextPageBtn').disabled = !p.has_next;
                    } else {
                        paginationControls.style.display = 'none';
                    }
                    
                    // æ˜¾ç¤ºåŠ è½½ä¿¡æ¯
                    if (result.data.clustered) {
                        console.log(`âœ… èšç±»ç®€åŒ–: ${result.data.stats.original_nodes} â†’ ${result.data.stats.clustered_nodes} èŠ‚ç‚¹`);
                    } else if (result.data.pagination) {
                        const p = result.data.pagination;
                        console.log(`âœ… åˆ†é¡µåŠ è½½: ç¬¬ ${p.page}/${p.total_pages} é¡µ (å…± ${p.total_nodes} èŠ‚ç‚¹)`);
                    } else {
                        console.log(`âœ… å®Œæ•´åŠ è½½: ${result.data.stats.total_nodes} èŠ‚ç‚¹`);
                    }
                } else {
                    alert('åŠ è½½å¤±è´¥: ' + (result ? result.error : 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('åŠ è½½å›¾å½¢å¤±è´¥:', error);
                alert('åŠ è½½å¤±è´¥: ' + error.message);
            } finally {
                isLoading = false;
                document.getElementById('loading').style.display = 'none';
            }
        }

        // åŠ è½½å®Œæ•´å›¾æ•°æ®
        async function loadFullGraph() {
            const response = await fetch('/visualizer/api/graph/full');
            return await response.json();
        }

        // åŠ è½½èšç±»ç®€åŒ–æ•°æ®
        async function loadClusteredGraph(maxNodes = 300) {
            const response = await fetch(`/visualizer/api/graph/clustered?max_nodes=${maxNodes}&cluster_threshold=10`);
            return await response.json();
        }

        // åŠ è½½åˆ†é¡µæ•°æ®
        async function loadPaginatedGraph(page = 1, pageSize = 500) {
            const response = await fetch(`/visualizer/api/graph/paginated?page=${page}&page_size=${pageSize}&min_importance=0.0`);
            return await response.json();
        }

        // æ›´æ–°å›¾å½¢æ˜¾ç¤ºï¼ˆä¼˜åŒ–ç‰ˆæœ¬ - ä½¿ç”¨èŠ‚ç‚¹é™åˆ¶å’Œå»¶è¿Ÿæ¸²æŸ“ï¼‰
        function updateGraph(data) {
            graphData = data;
            const nodeCount = data.nodes.length;
            const edgeCount = data.edges.length;

            console.log(`å‡†å¤‡æ›´æ–°å›¾å½¢: ${nodeCount} ä¸ªèŠ‚ç‚¹, ${edgeCount} æ¡è¾¹`);

            // å¯¹äºè¶…å¤§æ•°æ®é›†ï¼Œè¿›ä¸€æ­¥é™åˆ¶
            const MAX_RENDERABLE_NODES = 10000;
            const MAX_RENDERABLE_EDGES = 20000;
            
            let nodesToRender = data.nodes;
            let edgesToRender = data.edges;
            let isLimited = false;

            // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œåªæ¸²æŸ“æœ€é‡è¦çš„èŠ‚ç‚¹
            if (nodeCount > MAX_RENDERABLE_NODES) {
                console.warn(`èŠ‚ç‚¹æ•° ${nodeCount} è¶…è¿‡æ¸²æŸ“é™åˆ¶ ${MAX_RENDERABLE_NODES}ï¼Œå°†åªæ˜¾ç¤ºæœ€é‡è¦çš„èŠ‚ç‚¹`);
                
                // è®¡ç®—èŠ‚ç‚¹é‡è¦æ€§
                const nodeDegrees = new Map();
                data.edges.forEach(edge => {
                    nodeDegrees.set(edge.from, (nodeDegrees.get(edge.from) || 0) + 1);
                    nodeDegrees.set(edge.to, (nodeDegrees.get(edge.to) || 0) + 1);
                });
                
                // æŒ‰è¿æ¥åº¦æ’åºï¼Œä¿ç•™å‰Nä¸ª
                nodesToRender = data.nodes
                    .map(node => ({
                        ...node,
                        degree: nodeDegrees.get(node.id) || 0
                    }))
                    .sort((a, b) => b.degree - a.degree)
                    .slice(0, MAX_RENDERABLE_NODES);
                
                const renderableNodeIds = new Set(nodesToRender.map(n => n.id));
                edgesToRender = data.edges.filter(e => 
                    renderableNodeIds.has(e.from) && renderableNodeIds.has(e.to)
                );
                
                isLimited = true;
                alert(`âš ï¸ æ•°æ®é‡è¿‡å¤§\nåŸå§‹: ${nodeCount} èŠ‚ç‚¹\nä»…æ¸²æŸ“: ${nodesToRender.length} ä¸ªæœ€é‡è¦èŠ‚ç‚¹\nå»ºè®®ä½¿ç”¨"èšç±»ç®€åŒ–"æˆ–"åˆ†é¡µåŠ è½½"æ¨¡å¼`);
            }

            // å¦‚æœè¾¹æ•°è¿‡å¤šï¼Œä¹Ÿè¿›è¡Œé™åˆ¶
            if (edgesToRender.length > MAX_RENDERABLE_EDGES) {
                console.warn(`è¾¹æ•° ${edgesToRender.length} è¶…è¿‡æ¸²æŸ“é™åˆ¶ ${MAX_RENDERABLE_EDGES}`);
                edgesToRender = edgesToRender.slice(0, MAX_RENDERABLE_EDGES);
                isLimited = true;
            }

            // æ ¹æ®èŠ‚ç‚¹æ•°é‡åŠ¨æ€è°ƒæ•´ç½‘ç»œé…ç½®
            if (network.updateOptions) {
                network.updateOptions(nodesToRender.length);
            }

            console.log(`å®é™…æ¸²æŸ“: ${nodesToRender.length} ä¸ªèŠ‚ç‚¹, ${edgesToRender.length} æ¡è¾¹`);

            // æç®€åŒ–èŠ‚ç‚¹æ•°æ® - ç§»é™¤æ‰€æœ‰ä¸å¿…è¦çš„å±æ€§
            const startTime = performance.now();
            const nodes = nodesToRender.map(node => {
                const baseNode = {
                    id: node.id,
                    label: '',  // é»˜è®¤ä¸æ˜¾ç¤ºæ ‡ç­¾ï¼Œä»…åœ¨æ‚¬åœæˆ–é«˜äº®æ—¶æ˜¾ç¤º
                    group: node.group,
                    color: nodeColors[node.group] || '#999'
                };
                
                // ä»…åœ¨å°æ•°æ®é›†ä¸­æ·»åŠ titleï¼ˆtooltipï¼‰
                if (nodesToRender.length <= 1000) {
                    baseNode.title = node.title || node.label;
                }
                
                // å¦‚æœæ˜¯èšç±»èŠ‚ç‚¹ï¼Œä½¿ç”¨ä¸åŒçš„æ ·å¼å¹¶å§‹ç»ˆæ˜¾ç¤ºæ ‡ç­¾
                if (node.is_cluster) {
                    baseNode.shape = 'star';
                    baseNode.size = 25 + Math.min(node.cluster_size / 10, 15);
                    baseNode.label = `${node.group} (${node.cluster_size})`;
                    baseNode.font = { size: 14, bold: true };
                }
                
                return baseNode;
            });

            // æç®€åŒ–è¾¹æ•°æ®
            const edges = edgesToRender.map(edge => {
                const baseEdge = {
                    id: edge.id,
                    from: edge.from,
                    to: edge.to,
                    label: ''  // é»˜è®¤ä¸æ˜¾ç¤ºæ ‡ç­¾ï¼Œä»…åœ¨é«˜äº®æ—¶æ˜¾ç¤º
                };
                
                // åœ¨å°æ•°æ®é›†ä¸­ä¿ç•™è¾¹å®½åº¦
                if (edgesToRender.length <= 1000) {
                    baseEdge.width = (edge.importance || 0.5) * 2 + 0.5;
                }
                
                return baseEdge;
            });

            // æ‰¹é‡æ›´æ–°ç½‘ç»œï¼ˆä½¿ç”¨å¼‚æ­¥æ¸²æŸ“ä»¥é¿å…é˜»å¡UIï¼‰
            const prepTime = performance.now() - startTime;
            console.log(`æ•°æ®å‡†å¤‡è€—æ—¶: ${prepTime.toFixed(2)}ms`);
            
            // ä½¿ç”¨ requestAnimationFrame å¼‚æ­¥æ¸²æŸ“ï¼Œé¿å…é˜»å¡UI
            requestAnimationFrame(() => {
                const renderStart = performance.now();
                
                // å…ˆæ¸…ç©ºç°æœ‰æ•°æ®
                network.setData({
                    nodes: new vis.DataSet([]),
                    edges: new vis.DataSet([])
                });
                
                // åˆ†æ‰¹æ·»åŠ èŠ‚ç‚¹å’Œè¾¹ä»¥æå‡å“åº”æ€§
                const BATCH_SIZE = 500;
                let nodeIndex = 0;
                let edgeIndex = 0;
                
                const nodeDataSet = new vis.DataSet();
                const edgeDataSet = new vis.DataSet();
                
                function addNodeBatch() {
                    const batch = nodes.slice(nodeIndex, nodeIndex + BATCH_SIZE);
                    if (batch.length > 0) {
                        nodeDataSet.add(batch);
                        nodeIndex += BATCH_SIZE;
                        updateLoadingProgress(`åŠ è½½èŠ‚ç‚¹: ${Math.min(nodeIndex, nodes.length)}/${nodes.length}`);
                        
                        if (nodeIndex < nodes.length) {
                            setTimeout(addNodeBatch, 0);
                        } else {
                            // èŠ‚ç‚¹åŠ è½½å®Œæˆï¼Œå¼€å§‹åŠ è½½è¾¹
                            setTimeout(addEdgeBatch, 0);
                        }
                    }
                }
                
                function addEdgeBatch() {
                    const batch = edges.slice(edgeIndex, edgeIndex + BATCH_SIZE);
                    if (batch.length > 0) {
                        edgeDataSet.add(batch);
                        edgeIndex += BATCH_SIZE;
                        updateLoadingProgress(`åŠ è½½è¾¹: ${Math.min(edgeIndex, edges.length)}/${edges.length}`);
                        
                        if (edgeIndex < edges.length) {
                            setTimeout(addEdgeBatch, 0);
                        } else {
                            // æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆï¼Œæ›´æ–°ç½‘ç»œ
                            finishRendering();
                        }
                    }
                }
                
                function finishRendering() {
                    network.setData({
                        nodes: nodeDataSet,
                        edges: edgeDataSet
                    });
                    
                    const renderTime = performance.now() - renderStart;
                    console.log(`å›¾å½¢æ¸²æŸ“æ€»è€—æ—¶: ${renderTime.toFixed(2)}ms`);
                    updateLoadingProgress('æ¸²æŸ“å®Œæˆ');
                }
                
                // å¯¹äºå°æ•°æ®é›†ï¼Œç›´æ¥ä¸€æ¬¡æ€§åŠ è½½
                if (nodes.length <= 1000) {
                    nodeDataSet.add(nodes);
                    edgeDataSet.add(edges);
                    network.setData({
                        nodes: nodeDataSet,
                        edges: edgeDataSet
                    });
                    const renderTime = performance.now() - renderStart;
                    console.log(`å›¾å½¢æ¸²æŸ“æ€»è€—æ—¶: ${renderTime.toFixed(2)}ms`);
                } else {
                    // å¤§æ•°æ®é›†ä½¿ç”¨åˆ†æ‰¹åŠ è½½
                    addNodeBatch();
                }
            });
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats(stats) {
            document.getElementById('statNodes').textContent = stats.total_nodes;
            document.getElementById('statEdges').textContent = stats.total_edges;
            document.getElementById('statMemories').textContent = stats.total_memories;
            
            const density = stats.total_nodes > 0 
                ? ((stats.total_edges / (stats.total_nodes * (stats.total_nodes - 1))) * 100).toFixed(2)
                : 0;
            document.getElementById('statDensity').textContent = density + '%';
        }

        // æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
        function showNodeInfo(nodeId) {
            const node = graphData.nodes.find(n => n.id === nodeId);
            if (!node) return;

            const infoPanel = document.getElementById('nodeInfo');
            infoPanel.innerHTML = `
                <h3>${node.label}</h3>
                <p><strong>ç±»å‹:</strong> ${node.type}</p>
                <p><strong>ID:</strong> ${node.id.substring(0, 8)}...</p>
                <p><strong>åˆ›å»ºæ—¶é—´:</strong> ${new Date(node.created_at).toLocaleString('zh-CN')}</p>
                ${node.metadata && Object.keys(node.metadata).length > 0 
                    ? `<p><strong>å…ƒæ•°æ®:</strong> ${JSON.stringify(node.metadata, null, 2)}</p>`
                    : ''}
            `;
        }

        // æœç´¢è®°å¿†
        async function searchMemories() {
            const query = document.getElementById('searchInput').value;
            if (!query) {
                alert('è¯·è¾“å…¥æœç´¢å…³é”®è¯');
                return;
            }

            // å…ˆé‡ç½®é«˜äº®ï¼Œæ¸…é™¤ä¸Šä¸€æ¬¡çš„æœç´¢ç»“æœ
            resetNodeHighlight();

            try {
                const response = await fetch(`api/search?q=${encodeURIComponent(query)}&limit=50`);
                const result = await response.json();

                if (result.success) {
                    highlightSearchResults(result.data.results);
                } else {
                    alert('æœç´¢å¤±è´¥: ' + result.error);
                }
            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
                alert('æœç´¢å¤±è´¥: ' + error.message);
            }
        }

        // é«˜äº®æœç´¢ç»“æœ
        function highlightSearchResults(results) {
            const relatedNodeIds = new Set();
            results.forEach(result => {
                if (result.node_ids && result.node_ids.length > 0) {
                    result.node_ids.forEach(id => relatedNodeIds.add(id));
                }
            });

            if (relatedNodeIds.size === 0) {
                alert('æœªæ‰¾åˆ°ä¸æœç´¢ç»“æœç›´æ¥å…³è”çš„èŠ‚ç‚¹ã€‚\nè¿™å¯èƒ½å‘ç”Ÿåœ¨ä»æ—§ç‰ˆæ–‡ä»¶åŠ è½½æ•°æ®æ—¶ã€‚');
                return;
            }

            console.log(`é«˜äº® ${relatedNodeIds.size} ä¸ªæœç´¢ç»“æœèŠ‚ç‚¹`);

            const allNodes = network.body.data.nodes;
            const allEdges = network.body.data.edges;
            const nodeUpdates = [];
            const edgeUpdates = [];

            const nodesInViewIds = new Set(allNodes.getIds());
            const highlightedNodesInView = new Set();
            relatedNodeIds.forEach(id => {
                if (nodesInViewIds.has(id)) {
                    highlightedNodesInView.add(id);
                }
            });

            if (highlightedNodesInView.size === 0) {
                alert('æœç´¢åˆ°çš„è®°å¿†èŠ‚ç‚¹ä¸åœ¨å½“å‰è§†å›¾ä¸­ã€‚\nè¯·å°è¯•åˆ‡æ¢åˆ°â€œå®Œæ•´åŠ è½½â€æ¨¡å¼æˆ–è°ƒæ•´åˆ†é¡µ/èšç±»è®¾ç½®ã€‚');
                return;
            }

            // æ‰¾å‡ºè¿æ¥é«˜äº®èŠ‚ç‚¹çš„è¾¹
            const relatedEdgeIds = new Set();
            allEdges.get().forEach(edge => {
                if (highlightedNodesInView.has(edge.from) && highlightedNodesInView.has(edge.to)) {
                    relatedEdgeIds.add(edge.id);
                }
            });

            // æ›´æ–°èŠ‚ç‚¹æ ·å¼
            allNodes.get().forEach(node => {
                const originalNodeData = graphData.nodes.find(n => n.id === node.id);
                if (!originalNodeData) return;

                if (highlightedNodesInView.has(node.id)) {
                    nodeUpdates.push({
                        id: node.id,
                        color: nodeColors[node.group] || '#999',
                        opacity: 1.0,
                        label: originalNodeData.label || '',
                        font: { color: '#333', size: 14, strokeWidth: 2, strokeColor: 'white' }
                    });
                } else {
                    const originalColor = nodeColors[node.group] || '#999';
                    const dimmedColor = hexToRgba(originalColor, 0.1);
                    nodeUpdates.push({
                        id: node.id,
                        color: { background: dimmedColor, border: dimmedColor },
                        opacity: 0.1,
                        label: '',
                        font: { size: 0 }
                    });
                }
            });

            // æ›´æ–°è¾¹æ ·å¼
            allEdges.get().forEach(edge => {
                if (relatedEdgeIds.has(edge.id)) {
                    edgeUpdates.push({
                        id: edge.id,
                        color: { color: '#667eea', opacity: 1.0 },
                        width: 2.5
                    });
                } else {
                    edgeUpdates.push({
                        id: edge.id,
                        color: { color: '#848484', opacity: 0.05 },
                        width: 1
                    });
                }
            });

            allNodes.update(nodeUpdates);
            allEdges.update(edgeUpdates);

            network.fit({
                nodes: [...highlightedNodesInView],
                animation: { duration: 800, easingFunction: 'easeInOutQuad' }
            });

            alert(`é«˜äº®äº† ${highlightedNodesInView.size} ä¸ªç›¸å…³èŠ‚ç‚¹ã€‚\næ³¨æ„ï¼šå¦‚æœå¤„äºèšç±»æˆ–åˆ†é¡µæ¨¡å¼ï¼Œå¯èƒ½åªæ˜¾ç¤ºéƒ¨åˆ†èŠ‚ç‚¹ã€‚`);
        }

        // é«˜äº®ä¸é€‰ä¸­èŠ‚ç‚¹è¿æ¥çš„èŠ‚ç‚¹ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨ç¼“å­˜ï¼‰
        function highlightConnectedNodes(nodeId) {
            if (!network || !graphData || !adjacencyCache) return;

            const startTime = performance.now();
            
            // æ ¹æ®åŠ è½½æ¨¡å¼å’Œæ•°æ®è§„æ¨¡å†³å®šæ¢ç´¢æ·±åº¦
            // å®Œæ•´åŠ è½½æ¨¡å¼ï¼š1è·³
            // èšç±»/åˆ†é¡µæ¨¡å¼ï¼š3è·³ï¼ˆå› ä¸ºæ•°æ®é‡å·²ç»å‡å°‘ï¼‰
            const nodeCount = graphData.nodes.length;
            let MAX_DEPTH = 3;
            
            if (currentLoadMode === 'full' || (currentLoadMode === 'auto' && nodeCount <= 500)) {
                MAX_DEPTH = 1;  // å®Œæ•´åŠ è½½æ¨¡å¼é™åˆ¶ä¸º1è·³
                console.log('å®Œæ•´åŠ è½½æ¨¡å¼ï¼šä½¿ç”¨1è·³æ¢ç´¢æ·±åº¦');
            } else {
                console.log('èšç±»/åˆ†é¡µæ¨¡å¼ï¼šä½¿ç”¨3è·³æ¢ç´¢æ·±åº¦');
            }
            
            // ä½¿ç”¨ç¼“å­˜çš„é‚»æ¥è¡¨è¿›è¡Œ BFS
            const connectedNodeIds = new Set();
            const connectedEdgeIds = new Set();
            const visited = new Set();
            const queue = [{ nodeId: nodeId, depth: 0 }];

            // BFS éå†
            while (queue.length > 0) {
                const { nodeId: currentNode, depth } = queue.shift();
                
                if (visited.has(currentNode)) continue;
                visited.add(currentNode);
                connectedNodeIds.add(currentNode);

                if (depth >= MAX_DEPTH) continue;

                // ä½¿ç”¨ç¼“å­˜çš„é‚»æ¥è¡¨
                const neighbors = adjacencyCache.get(currentNode) || [];
                neighbors.forEach(({ nodeId: neighborId, edgeId }) => {
                    connectedEdgeIds.add(edgeId);
                    if (!visited.has(neighborId)) {
                        queue.push({ nodeId: neighborId, depth: depth + 1 });
                    }
                });
            }

            const searchTime = performance.now() - startTime;
            console.log(`BFSæœç´¢è€—æ—¶: ${searchTime.toFixed(2)}ms, æ‰¾åˆ° ${connectedNodeIds.size} ä¸ªè¿æ¥èŠ‚ç‚¹ (æ·±åº¦${MAX_DEPTH}è·³)`);

            // æ›´æ–°é«˜äº®èŠ‚ç‚¹é›†åˆ
            highlightedNodeIds = connectedNodeIds;

            // æ‰¹é‡æ›´æ–°èŠ‚ç‚¹å’Œè¾¹
            const allNodes = network.body.data.nodes;
            const allEdges = network.body.data.edges;
            const nodeUpdates = [];
            const edgeUpdates = [];

            // æ›´æ–°èŠ‚ç‚¹
            allNodes.get().forEach(node => {
                const originalNode = graphData.nodes.find(n => n.id === node.id);
                if (!originalNode) return;
                
                if (connectedNodeIds.has(node.id)) {
                    const isSelected = node.id === nodeId;
                    nodeUpdates.push({
                        id: node.id,
                        opacity: 1.0,
                        borderWidth: isSelected ? 5 : 3,
                        label: originalNode.label || '',  // æ˜¾ç¤ºé«˜äº®èŠ‚ç‚¹çš„æ ‡ç­¾
                        font: { 
                            color: isSelected ? '#667eea' : '#333', 
                            size: isSelected ? 16 : 14, 
                            bold: true 
                        }
                    });
                } else {
                    const originalColor = nodeColors[node.group] || '#999';
                    const dimmedColor = hexToRgba(originalColor, 0.08);
                    nodeUpdates.push({
                        id: node.id,
                        color: {
                            background: dimmedColor,
                            border: dimmedColor,
                        },
                        opacity: 0.08,
                        label: '',  // éšè—éé«˜äº®èŠ‚ç‚¹çš„æ ‡ç­¾
                        font: { color: 'rgba(51, 51, 51, 0.08)', size: 0 }
                    });
                }
            });

            // æ›´æ–°è¾¹
            allEdges.get().forEach(edge => {
                const originalEdge = graphData.edges.find(e => e.id === edge.id);
                
                if (connectedEdgeIds.has(edge.id)) {
                    edgeUpdates.push({
                        id: edge.id,
                        color: { color: '#667eea', opacity: 1.0 },
                        width: 4,
                        label: originalEdge?.label || '',  // æ˜¾ç¤ºé«˜äº®è¾¹çš„æ ‡ç­¾
                        font: { color: '#667eea', size: 12 }
                    });
                } else {
                    edgeUpdates.push({
                        id: edge.id,
                        color: { color: '#848484', opacity: 0.03 },
                        width: 1,
                        label: '',  // éšè—éé«˜äº®è¾¹çš„æ ‡ç­¾
                        font: { color: 'rgba(102, 102, 102, 0.03)', size: 0 }
                    });
                }
            });

            // æ‰¹é‡åº”ç”¨æ›´æ–°
            allNodes.update(nodeUpdates);
            allEdges.update(edgeUpdates);

            const totalTime = performance.now() - startTime;
            console.log(`é«˜äº®æ“ä½œæ€»è€—æ—¶: ${totalTime.toFixed(2)}ms`);

            // èšç„¦è§†å›¾
            if (connectedNodeIds.size > 1 && connectedNodeIds.size < 100) {
                network.fit({
                    nodes: Array.from(connectedNodeIds),
                    animation: {
                        duration: 800,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // é‡ç½®èŠ‚ç‚¹é«˜äº®çŠ¶æ€ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
        function resetNodeHighlight() {
            if (!network || !graphData) return;

            const startTime = performance.now();
            const allNodes = network.body.data.nodes;
            const allEdges = network.body.data.edges;

            // æ¸…ç©ºé«˜äº®èŠ‚ç‚¹é›†åˆ
            highlightedNodeIds.clear();

            // æ‰¹é‡æ¢å¤æ‰€æœ‰èŠ‚ç‚¹ï¼ˆä¸æ˜¾ç¤ºæ ‡ç­¾ï¼Œé™¤éæ˜¯æ‚¬åœèŠ‚ç‚¹ï¼‰
            const nodeUpdates = allNodes.get().map(node => {
                const originalColor = nodeColors[node.group] || '#999';
                const shouldShowLabel = node.id === hoveredNodeId;  // åªæ˜¾ç¤ºæ‚¬åœèŠ‚ç‚¹çš„æ ‡ç­¾
                const originalNode = shouldShowLabel ? graphData.nodes.find(n => n.id === node.id) : null;
                
                return {
                    id: node.id,
                    color: originalColor,
                    opacity: 1.0,
                    borderWidth: 2,
                    label: shouldShowLabel && originalNode ? originalNode.label : '',
                    font: { color: '#333', size: shouldShowLabel ? 14 : 0, bold: false }
                };
            });
            allNodes.update(nodeUpdates);

            // æ‰¹é‡æ¢å¤æ‰€æœ‰è¾¹ï¼ˆä¸æ˜¾ç¤ºæ ‡ç­¾ï¼‰
            const edgeUpdates = allEdges.get().map(edge => ({
                id: edge.id,
                color: { color: '#848484', opacity: 1.0 },
                width: 2,
                label: '',
                font: { color: '#666', size: 0 }
            }));
            allEdges.update(edgeUpdates);

            const endTime = performance.now();
            console.log(`é‡ç½®é«˜äº®è€—æ—¶: ${(endTime - startTime).toFixed(2)}ms`);
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º rgba
        function hexToRgba(hex, alpha) {
            // å¦‚æœå·²ç»æ˜¯ rgba æ ¼å¼ï¼Œç›´æ¥è¿”å›
            if (hex.startsWith('rgba')) return hex;
            
            // å¤„ç† # å¼€å¤´çš„åå…­è¿›åˆ¶
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // åº”ç”¨è¿‡æ»¤å™¨ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
        function applyFilters() {
            if (!originalData) return;

            const filters = {
                'SUBJECT': document.getElementById('filterSubject').checked,
                'TOPIC': document.getElementById('filterTopic').checked,
                'OBJECT': document.getElementById('filterObject').checked,
                'ATTRIBUTE': document.getElementById('filterAttribute').checked,
                'VALUE': document.getElementById('filterValue').checked
            };

            // è¿‡æ»¤èŠ‚ç‚¹
            const filteredNodes = originalData.nodes.filter(node => 
                filters[node.group]
            );
            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));

            // è¿‡æ»¤è¾¹ï¼ˆåªä¿ç•™ä¸¤ç«¯èŠ‚ç‚¹éƒ½å­˜åœ¨çš„è¾¹ï¼‰
            const filteredEdges = originalData.edges.filter(edge =>
                filteredNodeIds.has(edge.from) && filteredNodeIds.has(edge.to)
            );

            // æ›´æ–°å›¾å½¢
            updateGraph({
                nodes: filteredNodes,
                edges: filteredEdges,
                memories: originalData.memories,
                stats: {
                    total_nodes: filteredNodes.length,
                    total_edges: filteredEdges.length,
                    total_memories: originalData.stats.total_memories
                }
            });

            // é‡ç½®é«˜äº®çŠ¶æ€
            resetNodeHighlight();

            // é‡å»ºç¼“å­˜
            buildAdjacencyCache(filteredEdges);

            // é‡æ–°å¯ç”¨ç‰©ç†å¼•æ“ä»¥é‡æ–°å¸ƒå±€
            if (network && filteredNodes.length > 0) {
                network.setOptions({ physics: { enabled: true } });
                
                // è¶…æ—¶ä¿æŠ¤
                let stabilized = false;
                const timeout = setTimeout(() => {
                    if (!stabilized) {
                        console.log('ç‰©ç†å¼•æ“ç¨³å®šè¶…æ—¶ï¼Œå¼ºåˆ¶åœæ­¢');
                        network.setOptions({ physics: { enabled: false } });
                    }
                }, 5000);

                network.once('stabilizationIterationsDone', function() {
                    stabilized = true;
                    clearTimeout(timeout);
                    network.setOptions({ physics: { enabled: false } });
                    console.log('è¿‡æ»¤åé‡æ–°å¸ƒå±€å®Œæˆ');
                });
            }
        }

        // é€‚åº”çª—å£
        function fitNetwork() {
            if (network) {
                network.fit({
                    animation: {
                        duration: 1000,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // åˆ‡æ¢ç‰©ç†å¼•æ“
        function togglePhysics() {
            if (!network) return;
            
            const currentPhysics = network.physics.options.enabled;
            network.setOptions({ physics: { enabled: !currentPhysics } });
            
            const btn = document.getElementById('physicsToggle');
            btn.textContent = currentPhysics ? 'âš™ï¸ å¯ç”¨ç‰©ç†' : 'â¸ï¸ ç¦ç”¨ç‰©ç†';
            
            console.log(`ç‰©ç†å¼•æ“: ${currentPhysics ? 'å·²ç¦ç”¨' : 'å·²å¯ç”¨'}`);
        }

        // åŠ è½½ä¸‹ä¸€é¡µ
        async function loadNextPage() {
            if (currentPage < totalPages && !isLoading) {
                currentPage++;
                await loadPaginatedGraphAndUpdate();
            }
        }

        // åŠ è½½ä¸Šä¸€é¡µ
        async function loadPreviousPage() {
            if (currentPage > 1 && !isLoading) {
                currentPage--;
                await loadPaginatedGraphAndUpdate();
            }
        }

        // åŠ è½½åˆ†é¡µå¹¶æ›´æ–°UI
        async function loadPaginatedGraphAndUpdate() {
            try {
                isLoading = true;
                document.getElementById('loading').style.display = 'block';
                updateLoadingProgress(`åŠ è½½ç¬¬ ${currentPage} é¡µ...`);
                
                const result = await loadPaginatedGraph(currentPage);
                
                if (result.success) {
                    originalData = result.data;
                    updateGraph(result.data);
                    updateStats(result.data.stats);
                    buildAdjacencyCache(result.data.edges || []);
                    
                    // æ›´æ–°åˆ†é¡µUI
                    const p = result.data.pagination;
                    totalPages = p.total_pages;
                    document.getElementById('pageInfo').textContent = `ç¬¬ ${p.page}/${p.total_pages} é¡µ`;
                    document.getElementById('prevPageBtn').disabled = !p.has_prev;
                    document.getElementById('nextPageBtn').disabled = !p.has_next;
                }
            } catch (error) {
                console.error('åŠ è½½åˆ†é¡µå¤±è´¥:', error);
                alert('åŠ è½½å¤±è´¥: ' + error.message);
            } finally {
                isLoading = false;
                document.getElementById('loading').style.display = 'none';
            }
        }

        // å¯¼å‡ºå›¾å½¢æ•°æ®
        function exportGraph() {
            const dataStr = JSON.stringify(graphData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `memory_graph_${new Date().getTime()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // æ–‡ä»¶é€‰æ‹©åŠŸèƒ½
        async function loadFileList() {
            try {
                const response = await fetch('/visualizer/api/files');
                const result = await response.json();

                if (result.success) {
                    availableFiles = result.files;
                    updateCurrentFileInfo(result.current_file, result.files);
                    return result.files;
                } else {
                    console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', result.error);
                    return [];
                }
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                return [];
            }
        }

        function updateCurrentFileInfo(currentFile, files) {
            const infoDiv = document.getElementById('currentFileInfo');
            
            if (!currentFile || files.length === 0) {
                infoDiv.innerHTML = '<p style="color: #e74c3c;">âŒ æœªæ‰¾åˆ°æ•°æ®æ–‡ä»¶</p>';
                return;
            }

            const currentFileObj = files.find(f => f.path === currentFile);
            if (currentFileObj) {
                infoDiv.innerHTML = `
                    <div style="margin-bottom: 5px;"><strong>ğŸ“„ ${currentFileObj.name}</strong></div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>å¤§å°: ${currentFileObj.size_kb} KB</span>
                        <span>ä¿®æ”¹: ${currentFileObj.modified_readable.split(' ')[0]}</span>
                    </div>
                `;
            }
        }

        async function showFileSelector() {
            const modal = document.getElementById('fileModal');
            const container = document.getElementById('fileListContainer');
            
            modal.style.display = 'block';
            container.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="loading-spinner"></div>
                    <p>åŠ è½½æ–‡ä»¶åˆ—è¡¨...</p>
                </div>
            `;

            const files = await loadFileList();

            if (files.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <p style="font-size: 48px; margin-bottom: 10px;">ğŸ“­</p>
                        <p>æœªæ‰¾åˆ°ä»»ä½•æ•°æ®æ–‡ä»¶</p>
                        <p style="font-size: 12px; margin-top: 10px;">è¯·å…ˆè¿è¡ŒBotç”Ÿæˆè®°å¿†æ•°æ®</p>
                    </div>
                `;
                return;
            }

            let html = '<div class="file-list">';
            files.forEach(file => {
                const currentBadge = file.is_current ? '<span class="file-item-current">å½“å‰</span>' : '';
                html += `
                    <div class="file-item ${file.is_current ? 'current' : ''}" onclick="selectFile('${file.path.replace(/\\/g, '\\\\')}')">
                        <div class="file-item-name">ğŸ“„ ${file.name}${currentBadge}</div>
                        <div class="file-item-info">
                            <span>å¤§å°: ${file.size_kb} KB</span>
                            <span>${file.modified_readable}</span>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        function closeFileSelector() {
            document.getElementById('fileModal').style.display = 'none';
        }

        async function selectFile(filePath) {
            try {
                document.getElementById('loading').style.display = 'block';
                closeFileSelector();

                const response = await fetch('/visualizer/api/select_file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ file_path: filePath })
                });

                const result = await response.json();

                if (result.success) {
                    // é‡æ–°åŠ è½½å›¾å½¢
                    await loadGraph();
                    await loadFileList();
                    alert('âœ… ' + result.message);
                } else {
                    alert('âŒ åˆ‡æ¢æ–‡ä»¶å¤±è´¥: ' + result.error);
                }
            } catch (error) {
                console.error('åˆ‡æ¢æ–‡ä»¶å¤±è´¥:', error);
                alert('âŒ åˆ‡æ¢æ–‡ä»¶å¤±è´¥: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('fileModal');
            if (event.target == modal) {
                closeFileSelector();
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            initNetwork();
            loadGraph();
            loadFileList();
        });
    </script>
</body>
</html>
